use rayon::prelude::*;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::{exit, Command};

use crate::handle_failure;
use crate::psc_package;
use crate::types::*;

pub fn make_purs_packages_nix() {
    let dependencies = psc_package::get_dependencies();
    let packages = psc_package::get_packages();

    let infos: Vec<PackageInfo> = dependencies
        .iter()
        .map(|dep| {
            let package = packages
                .get(dep)
                .expect(&format!(r#"Could not find package for dep "{}""#, &dep));
            PackageInfo {
                name: dep.to_string(),
                repo: package.repo.clone(),
                version: package.version.clone(),
            }
        })
        .collect();

    let drvs: String = infos.par_iter().map(prepare_drv).collect();

    let contents = format!(
        r#"#Generated by soba https://github.com/justinwoo/soba
{{ pkgs ? import <nixpkgs> {{}} }}:

{{{drvs}}}
"#,
        drvs = drvs
    );

    let path = Path::new("purs-packages.nix");
    fs::write(path, contents).expect("Could not write purs-packages.nix. Why?");
}

pub fn prefetch_git(info: &PackageInfo) -> PrefetchResult {
    let path = get_cache_file_path(&info.name);

    if path.exists() {
        println!("Using cache entry for {} at {}", &info.name, &info.version);
        let string = fs::read_to_string(path).expect("Error reading cache file entry. Why?");
        return serde_json::from_str(&string)
            .expect("Could not parse cache file entry. You may need to delete ./cache/soba.");
    }

    println!(
        "No cache entry for {} at {}. Fetching...",
        &info.name, &info.version
    );

    let output = Command::new("nix-prefetch-git")
        .arg(&info.repo)
        .arg("--rev")
        .arg(&info.version)
        .output()
        .expect("Could not launch dhall. Make sure you have it in PATH.");

    if output.status.success() {
        let stdout: String = String::from_utf8_lossy(&output.stdout).into();
        println!(
            "Writing cache entry for {} at {}",
            &info.name, &info.version
        );
        fs::write(path, &stdout).expect("Error writing cache file entry. Why?");
        serde_json::from_str(&stdout).expect("Could not parse nix-prefetch-git output.")
    } else {
        handle_failure!("nix-prefetch-git", output);
    }
}

pub fn get_cache_file_path(package_name: &str) -> PathBuf {
    let dir = Path::new(".cache/soba");
    let mut target = PathBuf::new();
    target.push(dir);
    target.push(package_name);

    fs::create_dir_all(dir).expect("Could not create cache directory at .cache/soba.");

    target
}

pub fn prepare_drv(info: &PackageInfo) -> String {
    let result = prefetch_git(info);

    format!(
        r#"
    "{name}" = pkgs.stdenv.mkDerivation {{
      name = "{name}";
      version = "{version}";
      fetched = pkgs.fetchgit {{
        url = "{url}";
        rev = "{rev}";
        sha256 = "{sha256}";
      }};
    }};
"#,
        name = info.name,
        version = info.version,
        url = result.url,
        rev = result.rev,
        sha256 = result.sha256,
    )
}
